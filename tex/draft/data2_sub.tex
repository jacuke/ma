Dieser Abschnitt behandelt die versionsübergreifende Suche nach Umsteigern. Es geht also zum einen darum zu bestimmen, ob ein bestimmter Kode einer bestimmten Version sich überhaupt verändert hat, sowie zum anderen darum, abhängig von einer Start- und Zielversion zu ermitteln, welche Überleitungen von Kodes möglich sind. Die hier aufgeführten Algorithmen sind unabhängig von einer konkreten Implementation verfasst. 

§ Wichtig: 1 Umsteiger nur Veränderungen 2 Datenstrukturen

\section{Allgemeine Funktionen}

Grundlegend ist davon auszugehen, dass Funktionen zum Lesen der Daten vorliegen nach erfolgreicher Integration aus dem vorherigen Abschnitt. 

\subsection{Daten Lesen}
\label{function-read-data}

Konkret könnten zum Beispiel die Inhalte der Kodes- und Umsteiger-Dateien mit folgenden Parametern ausgelesen werden. 

\newpara{readData}

\begin{itemize}
\item \texttt{\$system} \newline Das Kodiersystem, beispielsweise als Konstanten definiert \texttt{'icd10gm'} und \texttt{'ops'}. 
\item \texttt{\$version} \newline Die Version, beziehungsweise Jahreszahl.
\item \texttt{\$code} \newline Ein Kode, nach dem gesucht wird. In Bezug auf die Notation von ICD-10-GM und OPS ist es sinnvoll automatisch an rechter Stelle einen Wildcard zu implizieren, das heißt einen Platzhalter für beliebige, weitere Zeichen. Dann werden mit einem leeren Kode-Wert auch alle Daten für die angegebenen Parameter gelesen. 
\item \texttt{\$type} \newline Die Art an Daten, die gelesen werden sollen. Für die Suche der Umsteiger werden folgende benötigt -- angegeben ebenfalls wieder als mögliche Konstanten:
  \begin{itemize}
  \item \texttt{'kodes'} \newline Kodes-Daten: Kode und Titel. 
  \item \texttt{'umsteiger'} \newline Umsteiger-Daten: alter Kode und neuer Kode, sowie Information über die automatische Überleitbarkeit in beide Richtungen. Es werden die Umsteiger von der angegebenen auf die nächstältere Version abgefragt. Suche über \${code} = neuer Kode. 
  \item \texttt{'umsteiger\_join'} \newline Wie Umsteiger-Daten, aber zusätzlich mit Titel für jeweils den alten und neuen Kode. "`Join"' bezieht sich auf die entsprechende Datenbankoperation.
  \item \texttt{'umsteiger\_join\_alt'} \newline Wie oben, außer dass die Suche über \${code} = alter Kode und in die andere Richtung erfolgt. Das heißt es wird die angegebene Version mit der nächstneueren Version verglichen. "`Alt"' für "`alternate"'.
  \end{itemize}
\end{itemize}

\subsection{Nächste Version}

Außerdem wird eine Funktion benötigt, die ausgehend von System und Version die jeweils nächstältere und -neuere Version ermittelt. Wenn diese nicht existiert, bleibt der Wert leer. 

Hierfür kann die in %\ref{struktdateiversionen}
{\color{blue} §TODO: Verweis im Kommentar}
erwähnte strukturierte Datei dienen, welche die Versionen und Abweichungen definiert. 

\newpara{nextNewerVersion / nextOlderVersion}

\begin{figure}[H]
    \centering\large%\sffamily
    \resizebox{.99\linewidth}{!}{\input{../dia/versions.tex}}
    \normalsize\vspace{-1em}\caption{Ermitteln der nächstliegenden Versionen am Beispiel von ICD-10-GM.}
\end{figure}

\subsection{Beispieldaten mit graphischer Darstellung}

Um beispielsweise die Kodes M21.4 und M21.6 aus der ICD-10-GM Version 2016 abzufragen, sehen die Funktionsaufrufe dann so aus:

\texttt{readData ('icd10gm', '2014', 'M21.4', 'kodes')} \newline
\texttt{readData ('icd10gm', '2014', 'M21.6', 'kodes')}

Und das Ergebnis als Tabelle:

%\begingroup
\begin{centernss}
\renewcommand{\arraystretch}{1.2}
\setlength{\tabcolsep}{12pt}
\begin{tabular}{ll}
code (Kode) & name (Titel) \\
\hline
M21.4 & Plattfuß [Pes planus] (erworben) \\
M21.6 & Sonstige erworbene Deformitäten des Knöchels und des Fußes \\
\end{tabular}
\end{centernss}
%\endgroup

Für den restlichen Abschnitt wird angenommen, dass die Ergebnisse der readData-Funktion in einer zweidimensionalen Datenstruktur gespeichert werden die einer Tabelle ähneln, das heißt eine Array-Liste mit einem Eintrag pro Zeile beginnend mit Index = 0, sowie einem assoziativen Array (Map oder auch eine Klassenstruktur) mit Key = Spaltenüberschrift. Der Zugriff auf den Titel "`Plattfuß"' in deren oberen Tabelle erfolgt dann über \texttt{\$data[ 0 ][ 'name' ]}.

Analog zu den Kodes können die Umsteiger wie folgt abgefragt werden: \newline
\texttt{lies\_daten ('icd10gm', '2014', 'M21.4', 'umsteiger')} \newline
\texttt{lies\_daten ('icd10gm', '2014', 'M21.6', 'umsteiger')}

Das Ergebnis sieht wie folgt aus; ``Auto'' steht für die automatische Überleitbarkeit in die jeweilige Richtung, das heißt 2014$\leftarrow$2013 und 2014$\rightarrow$2013.

%\begingroup
\begin{centernss}
\renewcommand{\arraystretch}{1.2}
\begin{tabular}{p{136pt}p{136pt}lr}
new (Kode Version 2014) & old (Kode Version 2013) & \multicolumn{2}{c}{$\leftarrow$Auto$\rightarrow$} \\
\hline
M21.4 & M21.4 & A & A \\
M21.6 & M21.6 & A & A \\
\end{tabular}
\end{centernss}
%\endgroup

Von Version 2014 auf 2013 ändern sich die angegebenen ICD-10-GM Kodes nicht. Wie bereits in der Datenintegration erwähnt, müssen diese Einträge gar nicht aufgenommen werden. Sie sind hier nur zur Vereinfachung aufgelistet, weil die Einträge auch so in den BfArM-Dateien enthalten sind. Bei der versionsübergreifenden Suche nach Umsteigern sind nur die Veränderungen relevant. Anstatt alle nicht relevanten Umsteiger-Einträge abzuspeichern und bei jeder Abfrage auszuschließen, kann alternativ auch angenommen werden, weil eine Suche nach Umsteigern immer von einem vorhanden Kode ausgeht, dass bei Nichtvorhandensein eines Umsteigers zwischen zwei Versionen dieser Kode einfach gleich bleibt.

Insgesamt treten bei M21.4 über alle Versionen keine Veränderungen in den Umsteigern auf. M21.6 hat allerdings folgende:

\begin{centernss}
\renewcommand{\arraystretch}{1.2}
\begin{tabular}{p{136pt}p{136pt}lr}
new (Kode Version 2015) & old (Kode Version 2014) & \multicolumn{2}{c}{$\leftarrow$Auto$\rightarrow$} \\
\hline
M21.4 & M21.4 & A & A \\
%\cline{1-1}%\hline%\hdashline[0.5pt/5pt]
M21.60 & M21.6 & & A \\
M21.61 & M21.6 & & A \\
M21.62 & M21.6 & & A \\
M21.63 & M21.6 & & A \\
M21.68 & M21.6 & & A \\
\end{tabular}
\end{centernss}

\begin{centernss}
\renewcommand{\arraystretch}{1.2}
\begin{tabular}{p{136pt}p{136pt}lr}
new (Kode Version 2013) & old (Kode Version 2012) & \multicolumn{2}{c}{$\leftarrow$Auto$\rightarrow$} \\
\hline
M21.4 & M21.4 & A & A \\
%\cline{1-1}%\hline%\hdashline[0.5pt/5pt]
M21.6 & M21.60 & A &  \\
M21.6 & M21.67 & A &  \\
M21.6 & M21.87 & A & A \\
\end{tabular}
\end{centernss}

\begin{comment}
\begin{centernss}
\renewcommand{\arraystretch}{1.2}
\begin{tabular}{p{136pt}p{136pt}lr}
new (Kode Version 2.0) & old (Kode Version 1.3) & \multicolumn{2}{c}{$\leftarrow$Auto$\rightarrow$} \\
\hline
M21.4 & M21.4 & A & A \\
%\cline{1-1}%\hline%\hdashline[0.5pt/5pt]
M21.60 & M21.6 &  & A \\
M21.67 & M21.6 &  & A \\
%\cline{1-1}%\hline%\hdashline[0.5pt/5pt]
M21.80 & M21.8 &  & A \\
M21.81 & M21.8 &  & A \\
M21.82 & M21.8 &  & A \\
M21.83 & M21.8 &  & A \\
M21.84 & M21.8 &  & A \\
M21.85 & M21.8 &  & A \\
M21.86 & M21.8 &  & A \\
M21.87 & M21.8 &  & A \\
M21.88 & M21.8 &  & A \\
M21.89 & M21.8 & A & A \\
\end{tabular}
\end{centernss}
\end{comment}

\begin{centernss}
\renewcommand{\arraystretch}{1.2}
\begin{tabular}{p{136pt}p{136pt}lr}
new (Kode Version 2.0) & old (Kode Version 1.3) & \multicolumn{2}{c}{$\leftarrow$Auto$\rightarrow$} \\
\hline
M21.4 & M21.4 & A & A \\
%\cline{1-1}%\hline%\hdashline[0.5pt/5pt]
M21.60 & M21.6 &  & A \\
M21.67 & M21.6 &  & A \\
%\cline{1-1}%\hline%\hdashline[0.5pt/5pt]
M21.87 & M21.8 &  & A \\
\end{tabular}
\end{centernss}

Anmerkung: Von Kode M21.8, Version 1.3. ausgehend gibt es noch wesentlich mehr Umsteiger, aber diese werden hier nicht gelistet, weil sind von M21.6, Version 2014 aus nicht erreichbar sind. 

\begin{comment}

\begin{minipage}[t]{.5\textwidth}\vspace{0pt}
%
\begingroup
\begin{tabular}{p{58pt}p{58pt}lr}
new (2015) & old (2014) & \multicolumn{2}{c}{$\leftarrow$Auto$\rightarrow$} \\
\hline
M21.4 & M21.4 & A & A \\
\cline{1-1}%\hline%\hdashline[0.5pt/5pt]
M21.60 & M21.6 & & A \\
M21.61 & M21.6 & & A \\
M21.62 & M21.6 & & A \\
M21.63 & M21.6 & & A \\
M21.68 & M21.6 & & A \\
\end{tabular}
%

\ \\

%\ \\

%
\begin{tabular}{p{58pt}p{58pt}lr}
new (2013) & old (2012) & \multicolumn{2}{c}{$\leftarrow$Auto$\rightarrow$} \\
\hline
M21.4 & M21.4 & A & A \\
\cline{1-1}%\hline%\hdashline[0.5pt/5pt]
M21.6 & M21.60 & A &  \\
M21.6 & M21.67 & A &  \\
M21.6 & M21.87 & A & A \\
\end{tabular}
\endgroup
%
\end{minipage}
\begin{minipage}[t]{.5\textwidth}%\vspace{0pt}
%
\begingroup
\renewcommand{\arraystretch}{1.2}
\begin{tabular}[t]{p{58pt}p{58pt}lr}
new (2.0) & old (1.3) & \multicolumn{2}{c}{$\leftarrow$Auto$\rightarrow$} \\
\hline
M21.4 & M21.4 & A & A \\
\cline{1-1}%\hline%\hdashline[0.5pt/5pt]
M21.60 & M21.6 &  & A \\
M21.67 & M21.6 &  & A \\
\cline{1-1}%\hline%\hdashline[0.5pt/5pt]
M21.80 & M21.8 &  & A \\
M21.81 & M21.8 &  & A \\
M21.82 & M21.8 &  & A \\
M21.83 & M21.8 &  & A \\
M21.84 & M21.8 &  & A \\
M21.85 & M21.8 &  & A \\
M21.86 & M21.8 &  & A \\
M21.87 & M21.8 &  & A \\
M21.88 & M21.8 &  & A \\
M21.89 & M21.8 & A & A \\
\end{tabular}
\endgroup
%
\end{minipage}
\end{comment}




\begin{comment}

2.0

M21.6;M21.60;;A
M21.6;M21.67;;A

M21.8;M21.80;;A
M21.8;M21.81;;A
M21.8;M21.82;;A
M21.8;M21.83;;A
M21.8;M21.84;;A
M21.8;M21.85;;A
M21.8;M21.86;;A
M21.8;M21.87;;A
M21.8;M21.88;;A
M21.8;M21.89;A;A

\end{comment}

Die Ergebnisse können als Graph dargestellt werden. Die Versionen sind horizontal angeordnet und die Kodes pro Version vertikal darunter als Knoten. Ausgangspunkt sind wie erwähnt die Kodes M21.4 und M21.6 der Version 2014. Die Knoten der anderen Versionen entsprechen den Kodes, die über Umsteiger erreichbar sind. Die Pfeilspitzen geben die Richtung der automatischen Überleitbarkeit an. 

\begin{figure}[H]
    \centering\Large%\sffamily
    \resizebox{.99\linewidth}{!}{\input{../dia/nodes.tex}}
    \normalsize\caption{Graphische Repräsentation der Umsteiger ausgehend von den Kodes M21.4 und M21.6 der ICD-10-GM Version 2014.}
\end{figure}

\section{Transitive Hülle}

Wenn statt der graphischen Repräsentation oben:

\begin{enumerate}
\item Die nicht relevanten Umsteiger ausgeschlossen werden; also wie besprochen die Umsteiger-Einträge ohne Veränderung von Kodes.
\item Die Kanten im Graph die Suchrichtung anzeigen statt der automatischen Überleitbarkeit.
\end{enumerate}

Dann ergibt sich ein gerichteter Graph. Das heißt ein Graph, der nur einfach gerichtete Kanten enthält und in dem jeder Knoten mit mindestens einem anderen Knoten über eine gerichtete Kante --auch Bogen genannt-- verbunden ist. Die Suche nach über Umsteiger erreichbaren Kodes entspricht daher der Bestimmung der transitiven Hülle in der Graphentheorie. 

\begin{figure}[H]
    \centering\Large%\sffamily
    \resizebox{.99\linewidth}{!}{\input{../dia/nodes2.tex}}
    \normalsize\caption{Von M21.6, Version 2014 erreichbare Kodes als gerichteter Graph.}
    \label{img-m21-6}
\end{figure}

Die transitive Hülle wird in \cite[Seite 172]{gross2013handbook} wie folgt definiert: 

\begin{figure}[H]
    \centering
    \setlength{\fboxsep}{10pt}\color{black!20}\fbox{
    \includegraphics[width=.85\linewidth]{../img/grapht1.png}}
    \normalcolor%\caption{aus \cite[Seite 172]{gross2013handbook}}
\end{figure}

Oder kurz zusammengefasst: die transitive Hülle eines gerichteten Graphens $G$ ist wiederum ein gerichteter Graph $G^*$, der von jedem Knoten einen Bogen zu allen von diesem Knoten aus in $G$ erreichbaren Nachbarn besitzt. 

In \cite[Seite 172]{gross2013handbook} ist hierzu folgendes Beispiel dargestellt:

\begin{figure}[H]
    \centering
    \setlength{\fboxsep}{10pt}\color{black!20}\fbox{
    \includegraphics[width=.85\linewidth]{../img/grapht2.png}}
    \normalcolor%\caption{aus \cite[Seite 172]{gross2013handbook}}
\end{figure}

Es gibt mehrere Verfahren, um die transitive Hülle zu bestimmen. Es werden nun zwei Algorithmen vorgestellt, die anhand ihrer primären Suchrichtung benannt sind. Wie in den Graphen dargestellt, läuft die \emph{horizontale} Suche primär über die Versionen --mit jeweils einzelnen Kodes-- und die \emph{vertikale} Suche primär über die Kodes --es werden zuerst alle Kodes einer Version gelesen.

\subsection{Horizontale Suche}

Ein intuitives Verfahren die transitive Hülle zu bestimmen wird in \cite[Seite 200]{jakobsson1991mixed} so beschrieben:

\begin{figure}[H]
    \centering
    \setlength{\fboxsep}{10pt}\color{black!20}\fbox{
    \includegraphics[width=.55\linewidth]{../img/search.png}}
    \normalcolor%\caption{aus \cite[Seite 200]{jakobsson1991mixed}}
    \vspace{-1em}
\end{figure}

Ähnlich wie vorherigen Abschnitt für den Kode M24.6 dargestellt, werden also einfach ausgehend von einem Knoten so viele Suchen gestartet bis keine benachbarten Knoten mehr gefunden werden -- oder im Anwendungsfall der Umsteiger bis alle Versionen verarbeitet wurden.

Ergebnisse für andere Knoten, beziehungsweise Kodes, werden ignoriert. Das hieße im Beispiel oben, dass eine rückwärts chronologische Suche nach Umsteigern von M21.60 und M21.61 der ICD-10-GM Version ab dem Vorgänger M21.6 der Version 2014 zweimal exakt gleich ablaufen würde. 

Der Pseudocode für diese Vorgehensweise:

\begin{comment}
\begin{centernss}
\begin{struktogramm}(95,50)[test]
\assign{%
\begin{declaration}[Parameter:]
\description{\pVar{iPar}}{ an \pKey{int} parameter with the meaning described here}
\end{declaration}
\begin{declaration}[local Variables:]
\description{\pVar{iVar}}{an \pKey{int} variable with the meaning
described here}
\description{\pVar{dVar}}{a \pKey{double} variable with the
meaning described here}
\end{declaration}
}
\end{struktogramm}
\end{centernss}

\newpage
\end{comment}

%\subsection{SearchHorizontal}

\newpara{searchHorizontal}

Funktionsparameter:

\begin{comment}
\begin{itemize}
\item \texttt{system} \newline Das Kodiersystem, also zum Beispiel \texttt{icd10gm} oder \texttt{ops}. 
\item \texttt{version} \newline Version, beziehungsweise Jahrgang. 
\item \texttt{code} \newline Kode, nach dem gesucht wird. 
\end{itemize}
\end{comment}

\begin{itemize}
\item \texttt{\$system}, \texttt{\$version}, \texttt{\$code} \newline 
Wie in Funktion \ref{function-read-data} readData.
\end{itemize}

Lokale Variable:

\begin{itemize}
\item \texttt{\$data} \hspace{2em} Rückgabewert, initial: leer.
\newline Eine assoziative Datenstruktur mit Key \texttt{fwd} $\Rightarrow$ Umsteiger, die chronologisch vorwärts von dem Suchkode erreichbar sind und \texttt{rev} $\Rightarrow$ chronologisch rückwärts. \\
\end{itemize}

\begin{comment}
\begingroup
\renewcommand{\arraystretch}{1.2}
\setlength{\tabcolsep}{12pt}
\begin{tabular}{|c|c|c|c|c|c|c|c|}
\hline
 & 2024 & 2023 & \dots & 2004 & 2.0 & 1.3 & \\
\hline
\end{tabular}
\endgroup
\end{comment}

\struktogrammAO{24}
{
\assign[\heightNS]{\$data[ 'fwd' ] = searchHorizontalRecursion (\$system, \$version, \$code, true)}
\assign[\heightNS]{\$data[ 'rev' ] = searchHorizontalRecursion (\$system, \$version, \$code, false)}
\return[\heightNS]{RETURN \$data}
}

\struktkommentar{Ausgehend von einem gegebenen Kode einer Version eines Kodiersystems wird chronologisch vorwärts und rückwärts eine rekursive Suche über alle Versionen gestartet.}

%\subsection{SearchHorizontalRecursion}

\newpara{searchHorizontalRecursion}

Funktionsparameter:

\begin{itemize}
\item \texttt{\$system}, \texttt{\$version}, \texttt{\$code} \newline Wie searchHorizontal. 
\item \texttt{\$chronological}
\newline Bestimmt die Suchrichtung. TRUE: chronologisch vorwärts und FALSE: rückwärts. 
\end{itemize}

Lokale Variablen:

\begin{itemize}
\item \texttt{\$data} \hspace{2em} Rückgabewert, initial: leer.
\newline Eine mehrdimensionale, assoziative Datenstruktur, die die Ergebnisse der rekursiven Suche enthält. Gefundene Umsteiger werden als Liste mit dem Key \texttt{umsteiger} gespeichert; zusätzlich zu der Listen auch die Versionen vorher und nachher. Jeder einzelne Umsteiger-Eintrag enthält wiederum die Informationen zur automatischen Überleitbarkeit, sowie die Titel der Kodes vorher und nachher. Falls ein Umsteiger weitere Umsteiger hat, werden diese unter dem einem Key \texttt{recursion} abgelegt und die Suche fortgesetzt. Das Beispielergebnis für M21.4 befindet sich im Anhang \ref{search-horizontal-example}.
\item \texttt{\$otherVersion} \newline Die Version, zu der die Umsteiger ermittelt werden.
\item \texttt{\$otherCode} \newline Die Kode, zu dem der aktuelle Kode übergeleitet wird.
\item \texttt{\$readType} \newline Auf welche Art die Daten gelesen werden; siehe \texttt{readData}.
\item \texttt{\$umsteiger}, \texttt{\$entry} \newline Liste der Umsteiger, Schleifenvariable: Umsteiger-Eintrag.
\item \texttt{\$recursion} \newline Ergebnis des rekursiven Funktionsaufrufs bei gefundenen Umsteigern. \\
\end{itemize}

\struktogrammAO{35}{
    \ifthenelse[10]{1}{1}{IF \$chronological}{Y}{N}
        \assign[\heightNS]{\$otherVersion = \newline nextNewerVersion(\$system, \$version)}
        \assign[\heightNS]{\$readType = 'umsteiger\_join\_alt'}
        \assign[\heightNS]{\$otherCode = 'new'}
    \change
        \assign[\heightNS]{\$otherVersion = \newline nextOlderVersion(\$system, \$version)}
        \assign[\heightNS]{\$readType = 'umsteiger\_join'}
        \assign[\heightNS]{\$otherCode = 'old'}
    \ifend
}

\struktkommentar{Lokale Variablen werden anhand der Suchrichtung unterschiedlich belegt.}

\struktogrammAO{16}{
    \ifthenelse[10]{5}{1}{IF empty(\$version) OR empty(\$otherVersion)}{Y}{}
        \return[\heightNS]{RETURN \$data}
    \change
    \ifend
}

\struktkommentar{Falls es in der Suchrichtung keine weitere Version mehr gibt, endet die Rekursion.}

\struktogrammAO{27}{
    \assign[\heightNS]{\$umsteiger = readData(\$system, \$version, \$code, \$readType)}
    \ifthenelse[10]{5}{1}{IF empty(\$umsteiger)}{Y}{}
        \return[\heightNS]{RETURN \newline searchHorizontalRecursion(\$type, \$otherVersion, \$code, \$chronological)}
    \change
    \ifend
}

\struktkommentar{Die Umsteiger zwischen den Versionen im aktuellen Rekursionsschritt werden ermittelt. Falls es keine gibt --also keine, die eine Veränderung ausdrücken-- dann wird die Rekursion mit der nächsten Version fortgesetzt.}

%\texttt{readData ('icd10gm', '2014', 'M21.4', 'kodes')} 

\struktogrammAO{54}{
    \while[\heightNS]{FOREACH \$entry IN \$umsteiger}
        \ifthenelse[10]{5}{1}{IF \$entry[ \$otherCode ] NOT 'UNDEF'}{Y}{}
            \assign[\heightNS]{\$recursion = searchHorizontalRecursion \newline (\$system, \$version, \$entry[ \$otherCode ], \$chronological)}
            \ifthenelse[10]{4}{1}{IF NOT empty(\$recursion)}{Y}{}
                \assign[\heightNS]{\$entry[ 'recursion' ] = \$recursion}
            \change
            \ifend
        \change
        \ifend
        \assign[\heightNS]{\$data[ 'umsteiger' ][ ] = \$entry}
    \whileend
}

\struktkommentar{Für jeden Umsteiger wird die Rekursion mit dem veränderten Kode fortgesetzt. Allerdings nur falls dieser nicht UNDEF ist, weil es sich dann um einen entfernten oder neu hinzugefügten Kode handelt. Also wenn wie im Beispiel der M21.6 der ICD-10-GM Version 2013 die Umsteiger [ M21.60, M21.67, M21.87 ] in der Version 2012 hat, dann wird die Suche in die rückwärts chronologische Richtung mit diesen drei Kodes fortgesetzt statt mit M21.6. Die Ergebnisse dieser Verzweigung, sofern vorhanden, werden abgespeichert mit dem Key \texttt{recursion} zusätzlich zu jedem Umsteiger-Eintrag. Die Liste aller Umsteiger-Einträge, inklusive der UNDEF-Umsteiger, wird in das Ergebnis mit dem Key \texttt{umsteiger} aufgenommen.}

\struktogrammAO{23}{
    \assign[\heightNS]{\$data[ 'version' ] = \$version}
    \assign[\heightNS]{\$data[ 'other' ] = \$otherVersion}
    \return[\heightNS]{RETURN \$data}
}

\struktkommentar{Falls es Umsteiger für einen Kode gibt, werden zusätzlich die Versionen vorher/nachher gespeichert. Dann endet auch hier die Rekursion.}

Appendix \ref{search-horizontal-example} enthält das Ergebnis im JSON-Format für den Beispielaufruf der horizontale Suche für M21.6, Version 2014
%\texttt{searchHorizontal('icd10gm', '2014', 'M21.6')}
entsprechend der Abbildung \ref{img-m21-6}.

\begin{comment}
\struktogrammA{200}{searchUmsteigerHorizontal\_recursion
}{
    \assign[\heightNS]{ret = [ ]}
    \ifthenelse[10]{3}{1}{IF version === ' '}{TRUE}{FALSE}
        \return[\heightNS]{RETURN ret}
    \change
    \ifend
    \ifthenelse[10]{1}{1}{IF chronological}{TRUE}{FALSE}
        \assign[\heightNS]{other = nextNewerVersion(type, version)}
        \assign[\heightNS]{table = 'umsteiger\_join\_rev'}
        \assign[\heightNS]{which = 'new'}
    \change
        \assign[\heightNS]{other = nextOlderVersion(type, version)}
        \assign[\heightNS]{table = 'umsteiger\_join'}
        \assign[\heightNS]{which = 'old'}
    \ifend
    \ifthenelse[10]{3}{1}{IF other === ' '}{TRUE}{FALSE}
        \return[\heightNS]{RETURN ret}
    \change
    \ifend
    \assign[\heightNS]{umsteiger = readData(type, table, version, year, other, code)}
    \ifthenelse[10]{3}{1}{IF empty(umsteiger)}{TRUE}{FALSE}
        \return[\heightNS]{RETURN searchHorizontalRec(type, other, code, chronological)}
    \change
    \ifend
    \assign[\heightNS]{data = [ ]}
    \while[\heightNS]{FOREACH item IN umsteiger}
        \assign[\heightNS]{code = item[which]}
        \ifthenelse[10]{5}{1}{IF code !== 'UNDEF'}{TRUE}{FALSE}
            \assign[\heightNS]{recursion = searchHorizontalRec(type, other, search, chronological)}
            \ifthenelse[10]{4}{1}{IF NOT empty(recursion)}{TRUE}{FALSE}
                \assign[\heightNS]{item['recursion'] = recursion}
            \change
            \ifend
        \change
        \ifend
        \assign[\heightNS]{data[ ] = item}
    \whileend
    \assign[\heightNS]{ret['umsteiger'] = data}
    \assign[\heightNS]{ret['version'] = version}
    \assign[\heightNS]{ret['other'] = other}
    \return[\heightNS]{RETURN ret}
}
\end{comment}

\begin{comment}
{\small
\begin{struktogramm}(170,200)[searchUmsteigerHorizontal\_recursion]
    \assign[\heightNS]{ret = [ ]}
    \ifthenelse[10]{3}{1}{IF version === ' '}{TRUE}{FALSE}
        \return[\heightNS]{RETURN ret}
    \change
    \ifend
    \ifthenelse[10]{1}{1}{IF chronological}{TRUE}{FALSE}
        \assign[\heightNS]{other = nextNewerVersion(type, version)}
        \assign[\heightNS]{table = 'umsteiger\_join\_rev'}
        \assign[\heightNS]{which = 'new'}
    \change
        \assign[\heightNS]{other = nextOlderVersion(type, version)}
        \assign[\heightNS]{table = 'umsteiger\_join'}
        \assign[\heightNS]{which = 'old'}
    \ifend
    \ifthenelse[10]{3}{1}{IF other === ' '}{TRUE}{FALSE}
        \return[\heightNS]{RETURN ret}
    \change
    \ifend
    \assign[\heightNS]{umsteiger = readData(type, table, version, year, other, code)}
    \ifthenelse[10]{3}{1}{IF empty(umsteiger)}{TRUE}{FALSE}
        \return[\heightNS]{RETURN searchHorizontalRec(type, other, code, chronological)}
    \change
    \ifend
    \assign[\heightNS]{data = [ ]}
    \while[\heightNS]{FOREACH item IN umsteiger}
        \assign[\heightNS]{code = item[which]}
        \ifthenelse[10]{5}{1}{IF code !== 'UNDEF'}{TRUE}{FALSE}
            \assign[\heightNS]{recursion = searchHorizontalRec(type, other, search, chronological)}
            \ifthenelse[10]{4}{1}{IF NOT empty(recursion)}{TRUE}{FALSE}
                \assign[\heightNS]{item['recursion'] = recursion}
            \change
            \ifend
        \change
        \ifend
        \assign[\heightNS]{data[ ] = item}
    \whileend
    \assign[\heightNS]{ret['umsteiger'] = umsteiger}
    \assign[\heightNS]{ret['version'] = version}
    \assign[\heightNS]{ret['other'] = other}
    \return[\heightNS]{RETURN ret}
\end{struktogramm}
}
\end{comment}

% Bei UNDEF: array_unshift($umsteiger_out, $find);

\subsection{Vertikale Suche}

Wie bereits erwähnt startet der Algorithmus der horizontalen Suche für jeden Kode bei Null. Gerade wenn die Umsteiger für alle Kodes einer Version -- beziehungsweise eines Kodiersystems-- gefunden werden sollen, ist diese Vorgehensweise nicht effizient. 

Besonders für gerichtete Graphen ist allerdings Purdoms Algorithmus gut geeignet, um die transitive Hülle zu bestimmen. Folgende kurze Beschreibung des Algorithmus basiert auf \cite{purdom1970transitive} und \cite[Seite 77]{dar1993augmenting}: 

\begin{enumerate}
\item Ausgehend von einem Graphen $G$: Bestimme die stark zusammenhängenden Komponenten ($SCC$) in $G$ und vereinige diese in jeweils einen einzelnen Knoten. Das ergibt einen zyklenfreien, verdichteten Graphen $G_c$.  %Let the original graph be G. Compute the strongly connected components in G, and collapse each one into a single node. Let the resulting acyclic condensation graph be Gc.
\item Sortiere $G_c$ topologisch. % Obtain a topological sort on Gc.
\item Ermittele die transitive Hülle von $G_c$ über dessen Adjazenzlisten in rückwärts topologischer Reihenfolge. % (Bestimme die erreichbaren Knoten über Adjazenzlisten) % Compute the transitive closure of Gc by expanding successor lists in reverse topological order.
\item Bestimme die transitive Hülle des ursprünglichen Graphens $G$ über die Nachbarschaftslisten der stark zusammenhängenen Komponenten in $G_c$: ein Knoten $y$ ist ein erreichbarer Nachbar von Knoten $x$, falls $SCC(y) = SCC(x)$ oder falls $SCC(y)$ ein erreichbarer Nachbar von $SCC(x)$ ist. % Compute the successor lists of the nodes in the original graph G from the successor lists of their respective SCCs: a node y is a successor of node x in G if SCC(y) = SCC(x) or SSC(y) is a succcessor of SCC(x) in Gc. 
\end{enumerate}

Die Vereinigung der stark zusammenhängenden Komponenten aus Schritt eins wird in \cite{purdom1970transitive} wie folgt dargestellt: 

\begin{figure}[H]
    \centering
    \includegraphics[width=.6\linewidth]{../img/purdom_g1.png}
%    \caption{Beispiel Graph $G$ von \cite[Seite 78]{purdom1970transitive}}
\end{figure}

\begin{figure}[H]
    \centering
    \includegraphics[width=.6\linewidth]{../img/purdom_g2.png}
    \caption{Beispielgraph $G$ und Vereinigung der stark zusammenhängenden Komponenten aus \cite[Seite 78]{purdom1970transitive}.}
\end{figure}

Die hier vorgestellte vertikale Suche nach Umsteigern entspricht nicht ganz Purdoms Algorithmus.

Zum Beispiel ist die topologische Sortierung aus Schritt zwei in der Anwendung der Suche nach Umsteigern nicht notwendig, weil die Versionen immer in einer bestimmte Richtung verglichen werden und die Kodes sich nur zwischen zwei Versionen ändern können. Die Daten sind also schon implizit topologisch sortiert. 

Aber die vertikale Suche verwendet wesentlich zwei Besonderheiten von Purdoms Algorithmus, die in \cite[Seite 76f]{dar1993augmenting} hervorgehoben werden:

\begin{figure}[H]
    \centering
    \setlength{\fboxsep}{10pt}\color{black!20}\fbox{
    \includegraphics[width=.95\linewidth]{../img/purdom_r.png}}
    \normalcolor%\caption{aus \cite[Seite 76f]{dar1993augmenting}}
\end{figure}

Konkret bedeuten diese Besonderheiten für die Umsteiger-Suche:

\begin{enumerate}
\item Topologisch rückwärts gerichtete Vorgehensweise: So ist zum Beispiel bei der Suche nach den Umsteigern eines ICD-GM-10 Kode der Version 1.3 die Reihenfolge, in der die anderen Versionen abgearbeitet werden: 2024, 2023, 2022 und so weiter. Oder anders ausgedrückt: Wenn die Überleitungen in chronologischer Reihenfolge bestimmt werden sollen, dann läuft die vertikale Suche umgekehrt, also chronologisch rückwärts. 
\item Vereinigung der stark zusammenhängenden Komponenten: Nach jedem Schritt über eine Version, wird geprüft, ob ein neu gefundener Umsteiger eine Überleitung in einen Kode enthält, der bereits in den davor abgearbeitet Versionen als Umsteiger vorkommt. Falls ja, dann werden diese Umsteiger vereinigt, das heißt die Zwischenschritte werden zu einem Schritt zusammengefügt. 
\end{enumerate}

Einfaches Beispiel für die Vereinigung: 

Angenommen ein abstraktes System hat Umsteiger von der Version 1.0 auf 2.0: $A$$\rightarrow$$B$ und $M$$\rightarrow$$N$, sowie von Version 2.0 auf 3.0: $B$$\rightarrow$$C$. Wenn nun in chronologischer Reihenfolge 1.0$\rightarrow$2.0$\rightarrow$3.0 Umsteiger ermittelt werden sollen, erfolgt die Suche sowie Vereinigung gefundener Umsteiger in umgekehrter Reihenfolge. Das heißt wenn im Schritt 3.0$\leftarrow$2.0 der Umsteiger $C$$\leftarrow$$B$ gefunden wird, dann wird danach bei der Vereinigung mit Version 1.0 der Umsteiger $B$$\leftarrow$$A$ in $C$$\leftarrow$$A$ umgewandelt. $A$ in Version 1.0 entspricht $C$ in Version 3.0. 

Falls es Verzweigungen gibt, also es mehrere Umsteiger für einen Kode gibt, dann werden entsprechend Listen vereinigt. Ein reales Beispiel dazu folgt später. 

\begin{figure}[H]
    \centering\Huge%\sffamily
    \resizebox{.75\linewidth}{!}{\input{../dia/merge.tex}}
    \normalsize\caption{Graphische Veranschaulichung der zwei Besonderheiten von Purdoms Algorithmus, die in der vertikalen Suche zur Anwendung kommen.}
\end{figure}

Die gesamte Algorithmus für die vertikale Suche als Pseudocode:

\newpara{searchVertical}

Funktionsparameter:

\begin{itemize}
\item \texttt{\$system} \newline Das Kodiersystem, beispielsweise als Konstanten definiert \texttt{'icd10gm'} und \texttt{'ops'}. 
\item \texttt{\$targetVersion} \newline Die Zielversion, auf die von allen anderen Version die Umsteiger über alle Kodes ermittelt werden.
\item \texttt{\$function} \newline Eine optionale, anonyme Funktion.
\end{itemize}

Lokale Variable:

\begin{itemize}
\item \texttt{\$data} \hspace{2em} Rückgabewert, initial: leer.
\newline Eine zweidimensionale, assoziative Datenstruktur -- wird nur befüllt wenn \texttt{\$function} nicht gesetzt ist. Die erste Dimension hat als Keys alle Versionen außer der Zielversion. Die zweite Dimension hat als Keys die Kodes der Version und als Value die Liste der zugehörigen Umsteiger, inklusive Vereinigung. Kodes ohne Umsteiger werden nicht aufgenommen.
\end{itemize}

\struktogrammAO{23}{
    \assign[\heightNS]{\$data += searchVerticalSubroutine(\$system, \$targetVersion, false, \$function)}
    \assign[\heightNS]{\$data += searchVerticalSubroutine(\$system, \$targetVersion, true, \$function)}
    \return[\heightNS]{RETURN \$data}
}

\struktkommentar{Basierend auf der Zielversionen wird in beide Richtungen die vertikale Suche als Unterfunktion gestartet.}

\texttt{\$data +=} bedeutet, dass die assoziativen Datenstrukturen zusammengefasst werden. Wenn ein Key auf beiden Seiten der Addition existiert, wird der von der linken Seite für die Summe übernommen. Das kann allerdings hier bei den Versionen als Keys nicht passieren, weil jede Version nur einmal bearbeitet wird. 

\newpara{searchVerticalSub}

Funktionsparameter:

\begin{itemize}
\item \texttt{\$system}, \texttt{\$targetVersion}, \texttt{\$function}  \newline Wie searchVertical. 
\item \texttt{\$chronological}
\newline Bestimmt die Richtung, in der die Versionen abgearbeitet werden. TRUE: chronologisch vorwärts und FALSE: rückwärts. Die Reihenfolge ist wie erwähnt topologisch rückwärts, das heißt ausgehend von der Zielversion. 
\end{itemize}

Lokale Variablen:

\begin{itemize}
\item \texttt{\$data \hspace{3em}} Rückgabewert, initial: leer.
\newline Eine zweidimensionale, assoziative Datenstruktur -- wird nur befüllt wenn \texttt{\$function} nicht gesetzt ist! Die erste Dimension hat als Keys alle Versionen außer der Zielversion. Die zweite Dimension hat als Keys die Kodes aller bisher verarbeiteten Umsteiger und als Values die Listen der Kodes, in die übergeleitet wird, inklusive Vereinigungen wie oben beschrieben. Das heißt im Gegensatz zur horizontalen Suche werden die Umsteiger als Key-Value Paare gespeichert: Kode der aktuellen Version $\Rightarrow$ Kode/s in die Vergleichsversion. Kodes ohne Umsteiger werden nicht aufgenommen.
\item \texttt{\$merge}  \newline bla
\item \texttt{\$version} \newline bla
\item \texttt{\$otherVersion} \newline bla
\end{itemize}

\struktogrammAO{100}{
    \assign[\heightNS]{\$version = \$targetVersion}
    \while[\heightNS]{WHILE TRUE}
        \assign[\heightNS]{\$otherVersion = \$version}
        \ifthenelse[10]{1}{1}{IF \$chronological}{Y}{N}
            \assign[\heightNS]{\$version = nextOlderVersion \newline (\$system, \$otherVersion)}
        \change
            \assign[\heightNS]{\$version = nextNewerVersion \newline (\$system, \$otherVersion)}
        \ifend
        \ifthenelse[10]{1}{1}{IF empty(\$version)}{Y}{}
            \return[\heightNS]{RETURN \$data}
        \change
        \ifend
        \ifthenelse[10]{1}{1}{IF \$chronological}{Y}{N}
            \assign[\heightNS]{\$merge = mergeUmsteiger \newline (\$system, \$chronological, \newline \$otherVersion, \$version, \$merge)}
        \change
            \assign[\heightNS]{\$merge = mergeUmsteiger \newline (\$system, \$chronological, \newline \$version, \$otherVersion, \$merge)}
        \ifend
        \ifthenelse[10]{1}{1}{IF \$function}{Y}{N}
            \assign[\heightNS]{\$function \newline (\$merge, \$version, \$targetVersion)}
        \change
            \assign[10]{\$data[ \$version ] = \$merge}
        \ifend
    \whileend
}

Q

\newpara{mergeUmsteiger}

Funktionsparameter:

\begin{itemize}
\item \texttt{\$system}, \texttt{\$target}, \texttt{\$function}  \newline Wie searchVertical. 
\item \texttt{\$chronological}
\newline Bestimmt die Richtung, in der die Versionen abgearbeitet werden. TRUE: chronologisch vorwärts und FALSE: rückwärts. Die Reihenfolge ist wie erwähnt topologisch rückwärts, das heißt ausgehend von der Zielversion. 
\end{itemize}

{\color{blue} §TODO: ab hier weitermachen}

Lokale Variable:

\begin{itemize}
\item \texttt{\$data} \hspace{2em} Rückgabewert, initial: leer.
\newline Eine zweidimensionale, assoziative Datenstruktur -- wird nur befüllt wenn \texttt{\$function} nicht gesetzt ist. Die erste Dimension hat als Keys alle Versionen außer der Zielversion. Die zweite Dimension hat als Keys die Kodes der Version und als Value die Liste der zugehörigen Umsteiger, inklusive Vereinigung. Kodes ohne Umsteiger werden nicht aufgenommen.
\item \texttt{\$merge} \newline bla, initial: leer.
\item \texttt{\$version} \newline bla, initial = target.
\end{itemize}



\struktogrammAO{140}{
    \assign[\heightNS]{umsteiger = [ ]}
    \ifthenelse[10]{1}{1}{IF chronological}{TRUE}{FALSE}
        \assign[\heightNS]{current = 'old'}
        \assign[\heightNS]{other = 'new'}
    \change
        \assign[\heightNS]{current = 'new'}
        \assign[\heightNS]{other = 'old'}
    \ifend
    \assign[\heightNS]{data = readData(type, 'umsteiger', version, prev)}
    \while[\heightNS]{FOREACH umst IN data}
        \assign[\heightNS]{current\_code = umst[current]}
        \assign[\heightNS]{other\_code = umst[other]}
        \ifthenelse[16]{1}{1}{IF current\_code==='UNDEF' OR other\_code==='UNDEF'}{TRUE}{FALSE}
            \assign[\heightNS]{undef = true}
        \change
            \assign[\heightNS]{undef = false}
        \ifend
        \ifthenelse[16]{1}{1}{IF NOT undef AND isset(merge\_into[other\_code])}{TRUE}{FALSE}
            \assign[\heightNS]{umsteiger[current\_code] =
            array\_merge(merge\_into[other\_code], umsteiger[current\_code] ?? [])}
        \change
            \assign[\heightNS]{umsteiger[current\_code] = other\_code}
        \ifend
    \whileend
    \return[\heightNS]{RETURN umsteiger + merge\_into}
}



\begin{figure}[H]
    \centering\Large%\sffamily
    \resizebox{.99\linewidth}{!}{\input{../dia/nodes3.tex}}
    \normalsize\caption{caption}
    \label{vertical-example}
\end{figure}

\begin{comment}
\begin{figure}[H]
    \centering
    \includegraphics[width=.49\linewidth]{../img/purdom_g1.png}
    \includegraphics[width=.49\linewidth]{../img/purdom_g2b.png}
    \caption{aus \cite[Seite 78]{purdom1970transitive}}
\end{figure}
\end{comment}

\begin{minipage}[t]{.5\textwidth}
test1
\end{minipage}
\begin{minipage}[t]{.5\textwidth}
test2
\end{minipage}

%\end{comment}

%% algo

\section{Vergleich der Suchalgorithmen}

Wenn die Daten aus einer Datenbank gelesen werden, dann ist der Menge pro readData Aufruf weniger entscheidend als die Anzahl solcher Aufrufe. Das heißt alle Umsteiger einer Version auf einmal zu lesen ist wesentlich schneller als sie einzeln zu lesen. 

Außerdem redundant

In dem Fall ist der

Horizontal:

Schneller bei einem Kode

Mehr Daten hinzufügbar. Vertikale Suche mit Titeln würde schnell mehrere hundert MB groß werden, Arbeitsspeicher.

Vertikal:

Schneller bei allen Kodes

Verwendung für ConceptMap

Verwendung für Bestimmen ob ein Kodes Umsteiger haben für alle Kodes und Versionen


\section{Schreiben der ConceptMap}

Appendix XML \ref{conceptmap-example}

